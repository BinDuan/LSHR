<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="author" content="Dmitriy Selivanov" />

<meta name="date" content="2015-06-16" />

<title>Locality Sensitive Hashing in R. Overview of LSHR package.</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>


<link href="data:text/css,body%20%7B%0A%20%20background%2Dcolor%3A%20%23fff%3B%0A%20%20margin%3A%201em%20auto%3B%0A%20%20max%2Dwidth%3A%20700px%3B%0A%20%20overflow%3A%20visible%3B%0A%20%20padding%2Dleft%3A%202em%3B%0A%20%20padding%2Dright%3A%202em%3B%0A%20%20font%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0A%20%20font%2Dsize%3A%2014px%3B%0A%20%20line%2Dheight%3A%201%2E35%3B%0A%7D%0A%0A%23header%20%7B%0A%20%20text%2Dalign%3A%20center%3B%0A%7D%0A%0A%23TOC%20%7B%0A%20%20clear%3A%20both%3B%0A%20%20margin%3A%200%200%2010px%2010px%3B%0A%20%20padding%3A%204px%3B%0A%20%20width%3A%20400px%3B%0A%20%20border%3A%201px%20solid%20%23CCCCCC%3B%0A%20%20border%2Dradius%3A%205px%3B%0A%0A%20%20background%2Dcolor%3A%20%23f6f6f6%3B%0A%20%20font%2Dsize%3A%2013px%3B%0A%20%20line%2Dheight%3A%201%2E3%3B%0A%7D%0A%20%20%23TOC%20%2Etoctitle%20%7B%0A%20%20%20%20font%2Dweight%3A%20bold%3B%0A%20%20%20%20font%2Dsize%3A%2015px%3B%0A%20%20%20%20margin%2Dleft%3A%205px%3B%0A%20%20%7D%0A%0A%20%20%23TOC%20ul%20%7B%0A%20%20%20%20padding%2Dleft%3A%2040px%3B%0A%20%20%20%20margin%2Dleft%3A%20%2D1%2E5em%3B%0A%20%20%20%20margin%2Dtop%3A%205px%3B%0A%20%20%20%20margin%2Dbottom%3A%205px%3B%0A%20%20%7D%0A%20%20%23TOC%20ul%20ul%20%7B%0A%20%20%20%20margin%2Dleft%3A%20%2D2em%3B%0A%20%20%7D%0A%20%20%23TOC%20li%20%7B%0A%20%20%20%20line%2Dheight%3A%2016px%3B%0A%20%20%7D%0A%0Atable%20%7B%0A%20%20margin%3A%201em%20auto%3B%0A%20%20border%2Dwidth%3A%201px%3B%0A%20%20border%2Dcolor%3A%20%23DDDDDD%3B%0A%20%20border%2Dstyle%3A%20outset%3B%0A%20%20border%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0A%20%20border%2Dwidth%3A%202px%3B%0A%20%20padding%3A%205px%3B%0A%20%20border%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0A%20%20border%2Dwidth%3A%201px%3B%0A%20%20border%2Dstyle%3A%20inset%3B%0A%20%20line%2Dheight%3A%2018px%3B%0A%20%20padding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0A%20%20border%2Dleft%2Dstyle%3A%20none%3B%0A%20%20border%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0A%20%20background%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0A%0Ap%20%7B%0A%20%20margin%3A%200%2E5em%200%3B%0A%7D%0A%0Ablockquote%20%7B%0A%20%20background%2Dcolor%3A%20%23f6f6f6%3B%0A%20%20padding%3A%200%2E25em%200%2E75em%3B%0A%7D%0A%0Ahr%20%7B%0A%20%20border%2Dstyle%3A%20solid%3B%0A%20%20border%3A%20none%3B%0A%20%20border%2Dtop%3A%201px%20solid%20%23777%3B%0A%20%20margin%3A%2028px%200%3B%0A%7D%0A%0Adl%20%7B%0A%20%20margin%2Dleft%3A%200%3B%0A%7D%0A%20%20dl%20dd%20%7B%0A%20%20%20%20margin%2Dbottom%3A%2013px%3B%0A%20%20%20%20margin%2Dleft%3A%2013px%3B%0A%20%20%7D%0A%20%20dl%20dt%20%7B%0A%20%20%20%20font%2Dweight%3A%20bold%3B%0A%20%20%7D%0A%0Aul%20%7B%0A%20%20margin%2Dtop%3A%200%3B%0A%7D%0A%20%20ul%20li%20%7B%0A%20%20%20%20list%2Dstyle%3A%20circle%20outside%3B%0A%20%20%7D%0A%20%20ul%20ul%20%7B%0A%20%20%20%20margin%2Dbottom%3A%200%3B%0A%20%20%7D%0A%0Apre%2C%20code%20%7B%0A%20%20background%2Dcolor%3A%20%23f7f7f7%3B%0A%20%20border%2Dradius%3A%203px%3B%0A%20%20color%3A%20%23333%3B%0A%7D%0Apre%20%7B%0A%20%20white%2Dspace%3A%20pre%2Dwrap%3B%20%20%20%20%2F%2A%20Wrap%20long%20lines%20%2A%2F%0A%20%20border%2Dradius%3A%203px%3B%0A%20%20margin%3A%205px%200px%2010px%200px%3B%0A%20%20padding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0A%20%20background%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0A%0Acode%20%7B%0A%20%20font%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0A%20%20font%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0A%20%20padding%3A%202px%200px%3B%0A%7D%0A%0Adiv%2Efigure%20%7B%0A%20%20text%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0A%20%20background%2Dcolor%3A%20%23FFFFFF%3B%0A%20%20padding%3A%202px%3B%0A%20%20border%3A%201px%20solid%20%23DDDDDD%3B%0A%20%20border%2Dradius%3A%203px%3B%0A%20%20border%3A%201px%20solid%20%23CCCCCC%3B%0A%20%20margin%3A%200%205px%3B%0A%7D%0A%0Ah1%20%7B%0A%20%20margin%2Dtop%3A%200%3B%0A%20%20font%2Dsize%3A%2035px%3B%0A%20%20line%2Dheight%3A%2040px%3B%0A%7D%0A%0Ah2%20%7B%0A%20%20border%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0A%20%20padding%2Dtop%3A%2010px%3B%0A%20%20padding%2Dbottom%3A%202px%3B%0A%20%20font%2Dsize%3A%20145%25%3B%0A%7D%0A%0Ah3%20%7B%0A%20%20border%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0A%20%20padding%2Dtop%3A%2010px%3B%0A%20%20font%2Dsize%3A%20120%25%3B%0A%7D%0A%0Ah4%20%7B%0A%20%20border%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0A%20%20margin%2Dleft%3A%208px%3B%0A%20%20font%2Dsize%3A%20105%25%3B%0A%7D%0A%0Ah5%2C%20h6%20%7B%0A%20%20border%2Dbottom%3A%201px%20solid%20%23ccc%3B%0A%20%20font%2Dsize%3A%20105%25%3B%0A%7D%0A%0Aa%20%7B%0A%20%20color%3A%20%230033dd%3B%0A%20%20text%2Ddecoration%3A%20none%3B%0A%7D%0A%20%20a%3Ahover%20%7B%0A%20%20%20%20color%3A%20%236666ff%3B%20%7D%0A%20%20a%3Avisited%20%7B%0A%20%20%20%20color%3A%20%23800080%3B%20%7D%0A%20%20a%3Avisited%3Ahover%20%7B%0A%20%20%20%20color%3A%20%23BB00BB%3B%20%7D%0A%20%20a%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0A%20%20%20%20text%2Ddecoration%3A%20underline%3B%20%7D%0A%20%20a%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0A%20%20%20%20text%2Ddecoration%3A%20underline%3B%20%7D%0A%0A%2F%2A%20Class%20described%20in%20https%3A%2F%2Fbenjeffrey%2Ecom%2Fposts%2Fpandoc%2Dsyntax%2Dhighlighting%2Dcss%0A%20%20%20Colours%20from%20https%3A%2F%2Fgist%2Egithub%2Ecom%2Frobsimmons%2F1172277%20%2A%2F%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%2F%2A%20Keyword%20%2A%2F%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%2F%2A%20DataType%20%2A%2F%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%2F%2A%20DecVal%20%28decimal%20values%29%20%2A%2F%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%2F%2A%20BaseN%20%2A%2F%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%2F%2A%20Float%20%2A%2F%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%2F%2A%20Char%20%2A%2F%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%2F%2A%20String%20%2A%2F%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%2F%2A%20Comment%20%2A%2F%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%2F%2A%20OtherToken%20%2A%2F%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%2F%2A%20AlertToken%20%2A%2F%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%2F%2A%20Function%20calls%20%2A%2F%20%0Acode%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%2F%2A%20ErrorTok%20%2A%2F%0A%0A" rel="stylesheet" type="text/css" />

</head>

<body>



<div id="header">
<h1 class="title">Locality Sensitive Hashing in R. Overview of LSHR package.</h1>
<h4 class="author"><em>Dmitriy Selivanov</em></h4>
<h4 class="date"><em>2015-06-16</em></h4>
</div>


<div id="locality-sensitive-hashing-in-r" class="section level1">
<h1>Locality Sensitive Hashing in R</h1>
<p>LSHR - fast and memory efficient package for reducing the dimensionality of high-dimensional data. Only minhashing implemented at the moment. Most of ideas are based on brilliant <a href="http://www.mmds.org">Mining of Massive Datasets</a> book - many thanks to authors.</p>
</div>
<div id="contents" class="section level1">
<h1>Contents</h1>
<p>In this vignette I will try to explain base concepts of <a href="http://en.wikipedia.org/wiki/Locality-sensitive_hashing">Locality Sensitive Hashing</a> and <a href="http://en.wikipedia.org/wiki/MinHash">Minhash</a> techniques. Also we will touch some details about implementation of these algorithms in <strong>LSHR</strong> package.</p>
<ol style="list-style-type: decimal">
<li><a href="#quick-reference">Quick reference</a></li>
<li><a href="#the-problem">Overview of the problem</a></li>
<li><a href="#minhashing">Minhashing</a></li>
<li><a href="#implementation">Implementation details</a></li>
</ol>
</div>
<div id="quick-reference" class="section level1">
<h1>Quick reference</h1>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">10</span>)
<span class="kw">library</span>(LSHR)
<span class="co"># generate element of sets</span>
elems &lt;-<span class="st"> </span><span class="kw">sapply</span>(<span class="dv">1</span>:<span class="dv">100</span>, function(z) 
  <span class="kw">paste</span>(<span class="kw">sample</span>(letters, <span class="kw">sample</span>(<span class="dv">3</span>:<span class="dv">7</span>), <span class="dt">replace =</span> T), <span class="dt">collapse=</span><span class="st">''</span>))
<span class="co"># generate sets</span>
sets &lt;-<span class="st">  </span><span class="kw">lapply</span>(<span class="dv">1</span>:<span class="dv">100</span>, function(z) <span class="kw">sample</span>(elems, <span class="kw">sample</span>(<span class="dv">10</span>:<span class="dv">40</span>)))
<span class="co"># add near-duplicates</span>
sets &lt;-<span class="st"> </span><span class="kw">c</span>(sets, <span class="kw">lapply</span>(sets[<span class="dv">1</span>:<span class="dv">10</span>], function(x) <span class="kw">c</span>(x, <span class="kw">sample</span>(elems, <span class="dv">5</span>))  ))
m &lt;-<span class="st"> </span><span class="kw">get_signature_matrix</span>(<span class="dt">sets =</span> sets, <span class="dt">hashfun_number =</span> <span class="dv">60</span>, <span class="dt">cores =</span> <span class="dv">2</span>)
candidate_indices &lt;-<span class="st"> </span><span class="kw">get_candidate_pairs</span>(<span class="dt">signature_matrix =</span> m, 
                                         <span class="dt">bands_number =</span> <span class="dv">10</span>, <span class="dt">similarity =</span> <span class="fl">0.8</span>, <span class="dt">verbose =</span> T)</code></pre>
<pre><code>## [1] &quot;Looking for sets with similarity 0.8&quot;
## [1] &quot;Probablity of becoming candidate pair = 0.952168265290506&quot;</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">candidate_indices</code></pre>
<pre><code>##     index1 index2 N
##  1:      1    101 5
##  2:      2    102 7
##  3:      3    103 4
##  4:      4    104 4
##  5:      5    105 2
##  6:      6    106 5
##  7:      7    107 5
##  8:      8    108 6
##  9:      9    109 4
## 10:     10    110 2</code></pre>
</div>
<div id="the-problem" class="section level1">
<h1>The problem</h1>
<p>Imagine the following interesting problems.</p>
<ul>
<li>We are developing a service similar to google news. And we want to <strong>clusterize</strong> similar news into groups so each group will represent cluster of articles about particular event. Of course there are a lot of methods for comapring text. One common is <a href="http://en.wikipedia.org/wiki/Cosine_similarity">cosine similarity</a>. But if we have millions of documents it is hard to compute this distance between each pair because of quadratic complexity. And it is hard to store such big similarity matrix.</li>
<li>We have two <em>very large</em> social netwotks (for example <em>facebook and google+</em>), which have hundreds of millions of profiles. And we want to determine profiles owned by same person - <strong>find near-duplicates</strong>. One reasonable approach is to assume that people who have particular firstname, lastname and nearly same, or at least highly overlapped, sets of friends in both networks are good candidates for detailed check.</li>
<li>you can find more applications of LSH <a href="http://en.wikipedia.org/wiki/Locality-sensitive_hashing#Applications">here</a> at Wikipedia.</li>
</ul>
<p>One well known measure for determining degree of similarity of sets is <a href="http://en.wikipedia.org/wiki/Jaccard_index">Jaccard Index</a> or Jaccard similarity:<br /><span class="math">\[J(SET_1, SET_2) = {|SET_1 \cap SET_2|\over |SET_1 \cup SET_2| }\]</span></p>
</div>
<div id="overview-of-minhashing-technique" class="section level1">
<h1>Overview of minhashing technique</h1>
<div id="possible-brute-force-solution" class="section level2">
<h2>Possible brute-force solution</h2>
<p>Let try to focus on <a href="#the-problem">second problem above</a>. At first look it seems that we easily can compute similarity of all pairs, because <code>union</code> and <code>intersection</code> set operations are quite cheap and fast.<br />Suppose we have <code>5000</code> <em>John Smith</em> profiles from <em>facebook</em> and <code>5000</code> <em>John Smith</em> profiles from <em>google+</em> - <code>10000</code> total. So we have to calclulate <code>5000 * 5000</code> (25 millions!) of jaccard distances to find good candidates.<br />First of all let’s generate artificial set of lastnames - we will pick “friends lastnames” for our candidates from this set.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># for reproducible results</span>
<span class="kw">set.seed</span>(<span class="dt">seed =</span> <span class="dv">17</span>)
<span class="co"># we like %&gt;% pipe operator! =)</span>
<span class="kw">library</span>(<span class="st">'magrittr'</span>)
<span class="co"># generate about 10000 &quot;lastnames&quot;</span>
lastnames &lt;-<span class="st"> </span><span class="kw">sapply</span>(<span class="dv">1</span>:<span class="fl">1e4</span>, function(x) 
  <span class="kw">sample</span>(letters, <span class="kw">sample</span>(<span class="dv">4</span>:<span class="dv">8</span>)) %&gt;%<span class="st"> </span><span class="kw">paste</span>(<span class="dt">collapse =</span> <span class="st">''</span>)) %&gt;%<span class="st"> </span>
<span class="st">  </span>unique
<span class="kw">print</span>(<span class="kw">head</span>(lastnames))</code></pre>
<pre><code>## [1] &quot;ofer&quot;    &quot;yxog&quot;    &quot;uwcnmte&quot; &quot;gsqxrp&quot;  &quot;yvgmtck&quot; &quot;gbcod&quot;</code></pre>
<p>Pick first pair of candidates, generate friends sets.</p>
<pre class="sourceCode r"><code class="sourceCode r">candidate_1_friends_set &lt;-<span class="st"> </span><span class="kw">sample</span>(lastnames, <span class="kw">sample</span>(<span class="dv">20</span>:<span class="dv">150</span>), <span class="dt">replace =</span> F)
candidate_2_friends_set &lt;-<span class="st"> </span><span class="kw">sample</span>(lastnames, <span class="kw">sample</span>(<span class="dv">20</span>:<span class="dv">150</span>), <span class="dt">replace =</span> F)</code></pre>
<p>Now we will try to evaluate computation time for our brure-force approach. Jaccard similarity:</p>
<pre class="sourceCode r"><code class="sourceCode r">jaccard &lt;-<span class="st"> </span>function(x, y) {
  set_intersection &lt;-<span class="st"> </span><span class="kw">length</span>(<span class="kw">intersect</span>(x, y))
  set_union &lt;-<span class="st"> </span><span class="kw">length</span>(<span class="kw">union</span>(x, y))
  <span class="kw">return</span>(set_intersection /<span class="st"> </span>set_union)
}</code></pre>
<p>Naive benchmark:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(microbenchmark)
timings &lt;-<span class="st"> </span><span class="kw">microbenchmark</span>(<span class="kw">jaccard</span>(candidate_1_friends_set, candidate_2_friends_set))
<span class="kw">print</span>(timings)</code></pre>
<pre><code>## Unit: microseconds
##                                                       expr    min     lq
##  jaccard(candidate_1_friends_set, candidate_2_friends_set) 24.728 25.795
##     mean  median      uq    max neval
##  31.3463 26.4595 38.8745 68.843   100</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">mean_timings &lt;-<span class="st"> </span><span class="kw">mean</span>(timings[[<span class="st">'time'</span>]])
<span class="co"># convert from nano-seconds to seconds</span>
mean_timings &lt;-<span class="st"> </span>mean_timings *<span class="st"> </span><span class="fl">1e-9</span></code></pre>
<p>On my computer one <code>jaccard()</code> call takes about 25 microseconds. So entire calculation will cost about 10 hours on my computer:</p>
<pre class="sourceCode r"><code class="sourceCode r">mean_timings *<span class="st"> </span><span class="dv">5000</span> *<span class="st"> </span><span class="dv">5000</span> /<span class="st"> </span><span class="dv">60</span></code></pre>
<pre><code>## [1] 13.06096</code></pre>
<p>May be this simple <code>jaccard()</code> implementation is not very effective and we can reduce computational time by a factor of 10-20 (which is quite reasonable - try to implement <code>jaccard()</code> function in pure C/C++). But even 1 hour is quite much for such toy example. Real-world datasets are much much larger. Then main problem is in <span class="math">\(O(n^2)\)</span> complexity of our brute-force algorithm.</p>
</div>
<div id="minhashing" class="section level2">
<h2>Minhashing</h2>
<p>To solve this kind problem we will use <a href="(http://en.wikipedia.org/wiki/Locality-sensitive_hashing)">Locality-sensitive hashing</a> - a method of performing probabilistic dimension reduction of high-dimensional data. It provides good tradeoff between accuracy and computational time and roughly speaking has <span class="math">\(O(n)\)</span> complexity.<br />I this vignette we will focus on one scheme of <strong>LSH</strong>, called <a href="http://en.wikipedia.org/wiki/MinHash">MinHashing</a>.<br />The intuition of the method is the following: we will try to hash the input items so that similar items are mapped to the same buckets with high probability (the number of buckets being much smaller than the universe of possible input items).<br />Let’s construct simple example:</p>
<pre class="sourceCode r"><code class="sourceCode r">set1 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">'SMITH'</span>, <span class="st">'JOHNSON'</span>, <span class="st">'WILLIAMS'</span>, <span class="st">'BROWN'</span>)
set2 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">'SMITH'</span>, <span class="st">'JOHNSON'</span>, <span class="st">'BROWN'</span>)
set3 &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">'THOMAS'</span>, <span class="st">'MARTINEZ'</span>, <span class="st">'DAVIS'</span>)
set_list &lt;-<span class="st"> </span><span class="kw">list</span>(set1, set2, set3)</code></pre>
<p>Now we have 3 sets to compare and identify profiles, related to same “John Smith”. From these sets we will construct matrix which encode relations between sets:</p>
<pre class="sourceCode r"><code class="sourceCode r">sets_dict &lt;-<span class="st"> </span><span class="kw">unlist</span>(set_list) %&gt;%<span class="st"> </span>unique
m &lt;-<span class="st"> </span><span class="kw">sapply</span>(set_list, <span class="dt">FUN =</span> function(set, dict) <span class="kw">as.integer</span>(dict %in%<span class="st"> </span>set), <span class="dt">dict =</span> sets_dict, <span class="dt">simplify =</span> T)
<span class="kw">dimnames</span>(m) &lt;-<span class="st"> </span><span class="kw">list</span>(sets_dict, <span class="kw">paste</span>(<span class="st">'set'</span>, <span class="dv">1</span>:<span class="kw">length</span>(set_list), <span class="dt">sep =</span> <span class="st">'_'</span>))</code></pre>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="right">set_1</th>
<th align="right">set_2</th>
<th align="right">set_3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">SMITH</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="left">JOHNSON</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td align="left">WILLIAMS</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="left">BROWN</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td align="left">THOMAS</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td align="left">MARTINEZ</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">1</td>
</tr>
<tr class="odd">
<td align="left">DAVIS</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">1</td>
</tr>
</tbody>
</table>
<p>Note, that this matrix is very similar to term-document matrix used in text-mining applications. Let’s call it matrix <strong>input-matrix</strong> <span class="math">\(M\)</span>. In our representation similarity of two sets from source array equal to the similarity of two corresponding columns with non-zero rows:</p>
<table>
<thead>
<tr class="header">
<th align="left">name</th>
<th align="left">set_1</th>
<th align="left">set_2</th>
<th align="left">intersecton</th>
<th align="left">union</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">SMITH</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">+</td>
<td align="left">+</td>
</tr>
<tr class="even">
<td align="left">JOHNSON</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">+</td>
<td align="left">+</td>
</tr>
<tr class="odd">
<td align="left">WILLIAMS</td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">-</td>
<td align="left">+</td>
</tr>
<tr class="even">
<td align="left">BROWN</td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">+</td>
<td align="left">+</td>
</tr>
<tr class="odd">
<td align="left">THOMAS</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
<tr class="even">
<td align="left">MARTINEZ</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
<tr class="odd">
<td align="left">DAVIS</td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">-</td>
<td align="left">-</td>
</tr>
</tbody>
</table>
<p>From table above we can conclude, that <strong>jaccard index between set_1 and set_2 is 0.75</strong>.<br />Let’s check:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="kw">jaccard</span>(set1, set2))</code></pre>
<pre><code>## [1] 0.75</code></pre>
<p>Prove that jaccard index between non-zero rows is equal to jaccard index between input sets:</p>
<pre class="sourceCode r"><code class="sourceCode r">column_jaccard &lt;-<span class="st">  </span>function(c1, c2) {
  non_zero &lt;-<span class="st"> </span><span class="kw">which</span>(c1 |<span class="st"> </span>c2)
  column_intersect &lt;-<span class="st"> </span><span class="kw">sum</span>(c1[non_zero] &amp;<span class="st"> </span>c2[non_zero])
  column_union &lt;-<span class="st"> </span><span class="kw">length</span>(non_zero)
  <span class="kw">return</span>(column_intersect /<span class="st"> </span>column_union)
}
<span class="kw">isTRUE</span>(<span class="kw">jaccard</span>(set1, set2) ==<span class="st"> </span><span class="kw">column_jaccard</span>(m[, <span class="dv">1</span>], m[, <span class="dv">2</span>]))</code></pre>
<pre><code>## [1] TRUE</code></pre>
<div id="minhashing-algorithm" class="section level3">
<h3>Minhashing algorithm</h3>
<ol style="list-style-type: decimal">
<li>Pick column <span class="math">\(c\)</span> from <strong>input-matrix</strong> <span class="math">\(M\)</span>.</li>
<li>Define <strong>minhash function</strong> <span class="math">\(h(c)\)</span> = # of first row in which column <span class="math">\(c == 1\)</span>.</li>
<li>Now suppose random permutation of rows of the <span class="math">\(M\)</span>. If we will use <span class="math">\(N\)</span> <strong>independent</strong> permutations we will end with <span class="math">\(N\)</span> <strong>minhash functions</strong>. So now we can construct <strong>signature-matrix</strong> from <span class="math">\(M\)</span> using these minhash functions:</li>
</ol>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># for our toy example we will pick N = 4</span>
N &lt;-<span class="st"> </span><span class="dv">4</span>
sm &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dt">data =</span> <span class="ot">NA_integer_</span>, <span class="dt">nrow =</span> N, <span class="dt">ncol =</span> <span class="kw">ncol</span>(m))
perms &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dt">data =</span> <span class="ot">NA_integer_</span>, <span class="dt">nrow =</span> <span class="kw">nrow</span>(m), <span class="dt">ncol =</span> N)
<span class="co"># calculate indexes for non-zero entries for each column</span>
non_zero_row_indexes &lt;-<span class="st"> </span><span class="kw">apply</span>(m, <span class="dt">MARGIN =</span> <span class="dv">2</span>, <span class="dt">FUN =</span> function(x) <span class="kw">which</span> (x !=<span class="st"> </span><span class="dv">0</span>) )
for (i in <span class="dv">1</span> :<span class="st"> </span>N) {
  <span class="co"># calculate permutations</span>
  perm &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="kw">nrow</span>(m))
  perms[, i] &lt;-<span class="st"> </span>perm
  <span class="co"># fill row of signature matrix</span>
  for (j in <span class="dv">1</span>:<span class="kw">ncol</span>(m))
    sm[i, j] &lt;-<span class="st">  </span><span class="kw">min</span>(perm[non_zero_row_indexes[[j]]])
}
<span class="kw">print</span>(sm)</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    1    3
## [2,]    2    2    1
## [3,]    2    4    1
## [4,]    3    3    1</code></pre>
<p>In chunk above we did it not very efficiently with 2 nested <code>for</code> loops. But the logic should be very clear.</p>
<p>You can see how we obtain <strong>signature-matrix</strong> matrix after “minhash transformation”. Permutations and corresponding signatures marked with same colors:</p>
<table>
<thead>
<tr class="header">
<th align="left">perm_1</th>
<th align="left">perm_2</th>
<th align="left">perm_3</th>
<th align="left">perm_4</th>
<th align="left">set_1</th>
<th align="left">set_2</th>
<th align="left">set_3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><span style="background-color:lightgreen">4 </span></td>
<td align="left"><span style="background-color:orange">1 </span></td>
<td align="left"><span style="background-color:lightblue">4 </span></td>
<td align="left"><span style="background-color:yellow">6 </span></td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr class="even">
<td align="left"><span style="background-color:lightgreen">3 </span></td>
<td align="left"><span style="background-color:orange">4 </span></td>
<td align="left"><span style="background-color:lightblue">1 </span></td>
<td align="left"><span style="background-color:yellow">1 </span></td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr class="odd">
<td align="left"><span style="background-color:lightgreen">7 </span></td>
<td align="left"><span style="background-color:orange">6 </span></td>
<td align="left"><span style="background-color:lightblue">6 </span></td>
<td align="left"><span style="background-color:yellow">2 </span></td>
<td align="left">1</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
<tr class="even">
<td align="left"><span style="background-color:lightgreen">6 </span></td>
<td align="left"><span style="background-color:orange">2 </span></td>
<td align="left"><span style="background-color:lightblue">7 </span></td>
<td align="left"><span style="background-color:yellow">3 </span></td>
<td align="left">1</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
<tr class="odd">
<td align="left"><span style="background-color:lightgreen">5 </span></td>
<td align="left"><span style="background-color:orange">3 </span></td>
<td align="left"><span style="background-color:lightblue">2 </span></td>
<td align="left"><span style="background-color:yellow">5 </span></td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left"><span style="background-color:lightgreen">2 </span></td>
<td align="left"><span style="background-color:orange">5 </span></td>
<td align="left"><span style="background-color:lightblue">3 </span></td>
<td align="left"><span style="background-color:yellow">7 </span></td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
<tr class="odd">
<td align="left"><span style="background-color:lightgreen">1 </span></td>
<td align="left"><span style="background-color:orange">7 </span></td>
<td align="left"><span style="background-color:lightblue">5 </span></td>
<td align="left"><span style="background-color:yellow">4 </span></td>
<td align="left">0</td>
<td align="left">0</td>
<td align="left">1</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th align="left">set_1</th>
<th align="left">set_2</th>
<th align="left">set_3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><span style="background-color:lightgreen">3</span></td>
<td align="left"><span style="background-color:lightgreen">3</span></td>
<td align="left"><span style="background-color:lightgreen">1</span></td>
</tr>
<tr class="even">
<td align="left"><span style="background-color:orange">1</span></td>
<td align="left"><span style="background-color:orange">1</span></td>
<td align="left"><span style="background-color:orange">3</span></td>
</tr>
<tr class="odd">
<td align="left"><span style="background-color:lightblue">1</span></td>
<td align="left"><span style="background-color:lightblue">1</span></td>
<td align="left"><span style="background-color:lightblue">2</span></td>
</tr>
<tr class="even">
<td align="left"><span style="background-color:yellow">1</span></td>
<td align="left"><span style="background-color:yellow">1</span></td>
<td align="left"><span style="background-color:yellow">4</span></td>
</tr>
</tbody>
</table>
<p>Notice that <span class="math">\(set_1\)</span> and <span class="math">\(set_2\)</span> signatures are very similar and signature of <span class="math">\(set_3\)</span> dissimilar with <span class="math">\(set_1\)</span> and <span class="math">\(set_2\)</span>.</p>
<pre class="sourceCode r"><code class="sourceCode r">jaccard_signatures &lt;-<span class="st">  </span>function(c1, c2) {
  column_intersect &lt;-<span class="st"> </span><span class="kw">sum</span>(c1 ==<span class="st"> </span>c2)
  column_union &lt;-<span class="st"> </span><span class="kw">length</span>(c1)
  <span class="kw">return</span>(column_intersect /<span class="st"> </span>column_union)
}
<span class="kw">print</span>(<span class="kw">jaccard_signatures</span>(sm[, <span class="dv">1</span>], sm[, <span class="dv">2</span>]))</code></pre>
<pre><code>## [1] 0.75</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">print</span>(<span class="kw">jaccard_signatures</span>(sm[, <span class="dv">1</span>], sm[, <span class="dv">3</span>]))</code></pre>
<pre><code>## [1] 0</code></pre>
</div>
<div id="intuition" class="section level3">
<h3>Intuition</h3>
<p>Intuition is very straighforward. Let’s look down the permuted columns <span class="math">\(c_1\)</span> and <span class="math">\(c_2\)</span> until we detect <strong>1</strong>.<br /> * If in both columns we find ones - (1, 1), then <span class="math">\(h(c_1) = h(c_2)\)</span>. * In case (0, 1) or (1, 0) <span class="math">\(h(c_1) \neq h(c_2)\)</span>. So the probability over all permutations of non-zero rows that <span class="math">\(h(c_1) = h(c_2)\)</span> is the same as <span class="math">\(J(c_1, c_2)\)</span>.</p>
</div>
<div id="theoretical-guaranties" class="section level3">
<h3>Theoretical guaranties</h3>
<p>Moreover there exist theoretical guaranties for estimation of Jaccard similarity: for any constant <span class="math">\(\varepsilon &gt; 0\)</span> there is a constant <span class="math">\(k = O(1/\varepsilon^2)\)</span> - number of permutations - such that the expected error of the estimate is at most <span class="math">\(\varepsilon\)</span>.</p>
</div>
</div>
</div>
<div id="implementation" class="section level1">
<h1>Implementation</h1>
<p>Aim of this package is to be fast and memory efficient. We use <a href="https://github.com/RcppCore/Rcpp">Rcpp</a>, <a href="https://github.com/s-u/fastmatch">fastmatch</a> and <a href="github.com/Rdatatable/data.table/">data.table</a> packages.</p>
<p>There few challenges in developing efficient implementation of minhashing:</p>
<ol style="list-style-type: decimal">
<li>Construction of <strong>input-matrix</strong> <span class="math">\(M\)</span>.</li>
</ol>
<ul>
<li>storage size and computational efficiency</li>
</ul>
<ol start="2" style="list-style-type: decimal">
<li>Signature matrix construction</li>
</ol>
<ul>
<li>permutations are expensive! using many hash functions.</li>
<li>construction of hash function family</li>
</ul>
<ol start="3" style="list-style-type: decimal">
<li>Locality Sensitive Hashing</li>
</ol>
<ul>
<li>number of buckets</li>
<li>theoretical guaranties</li>
</ul>
<div id="construction-of-input-term-document-matrix" class="section level2">
<h2>Construction of input term-document matrix</h2>
<p><strong>TODO</strong></p>
</div>
<div id="signature-matrix-construction" class="section level2">
<h2>Signature matrix construction</h2>
<p>Suppose <strong>input-matrix</strong> is very big, say <code>1e9</code> rows. It is quite hard computationally to permute 1 billion rows. Also you need to store these entries and access these values. It is common to use following scheme instead:</p>
<ul>
<li>Pick <span class="math">\(N\)</span> independent hash functions <span class="math">\(h_i(c)\)</span> instead of <span class="math">\(N\)</span> premutations, <span class="math">\(i = 1..N\)</span>.<br /></li>
<li>For each column <span class="math">\(c\)</span> and each hash function <span class="math">\(h_i\)</span>, keep a “slot” <span class="math">\(M(i, c)\)</span>.<br /></li>
<li><span class="math">\(M(i, c)\)</span> will become the smallest value of <span class="math">\(h_i(r)\)</span> for which column <span class="math">\(c\)</span> has 1 in row <span class="math">\(r\)</span>. I.e., <span class="math">\(h_i(r)\)</span> gives order of rows for <span class="math">\(i^{th}\)</span> permutation.</li>
</ul>
<p>So we end up with following <strong>ALGORITHM(1)</strong> from excellent <a href="http://www.mmds.org">Mining of Massive Datasets</a> book:</p>
<pre><code>for each row r do begin
  for each hash function hi do
    compute hi (r);
  for each column c
    if c has 1 in row r
      for each hash function hi do
        if hi(r) is smaller than M(i, c) then
          M(i, c) := hi(r);
end;</code></pre>
</div>
<div id="locality-sensitive-hashing" class="section level2">
<h2>Locality Sensitive Hashing</h2>
<p><strong>TODO</strong></p>
</div>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
